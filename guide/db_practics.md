---
layout: page
title: "Практика работы с MySQL"
permalink: db_practics.html
---

## Поддержка MySQL в PHP
В PHP есть превосходная поддержка базы данных MySQL.  
Специальные встроенные функции для работы с MySQL позволяют просто и эффективно работать с этой СУБД: выполнять любые запросы, читать и записывать данные, обрабатывать ошибки.  
Сценарий, который подключается к БД, выполняет запрос и показывает результат будет состоять всего из нескольких строк.
Для работы с MySQL не надо ничего дополнительно устанавливать и настраивать; всё что необходимо уже доступно вместе со стандартной поставкой PHP.

### Что такое mysqli?
mysqli (MySQL Improved) - это расширение PHP, которое добавляет в язык полную поддержку баз данных MySQL.  Это расширение поддерживает множество возможностей современных версий MySQL.

## Как выглядит работа с базой данных
Типичный процесс работы с СУБД в PHP-сценарии состоит из нескольких шагов:
1. Установить подключение к серверу СУБД, передав необходимые параметры: адрес, логин, пароль
2. Убедиться, что подключение прошло успешно: сервер СУБД доступен, логин и пароль верные и т.д.
3. Сформировать правильный SQL запрос (например, на чтение данных из таблицы)
4. Убедиться, что запрос был выполнен успешно
5. Получить результат от СУБД в виде массива из записей
6. Использоваеть полученные записи в своем сценарии (например, показать их в виде таблицы)

## Соединение с MySQL
Перед тем, как начать работать с данными внутри MySQL, вам необходимо открыть соединение с сервером СУБД.  
В PHP это делается с помощью стандартной функции `mysqli_connect()`.  Функция возвращает результат - ресурс соединения. Данный ресурс используется для всех следующих операций с MySQL.
 
Но чтобы выполнить соединение с сервером, необходимо знать как минимум три параметра: 
* адрес сервера СУБД
* логин 
* пароль  

Если вы следовали стандартной процедуре установки MySQL или используете OpenServer, то адресом сервера будет `localhost`, логином - `root`. 
При использовании OpenServer пароль для подключения - это пустая строка '', а при самостоятельной установке MySQL пароль ты задавал в одном из шагов мастера установки.

Базовый синтаксис функции `mysqli_connect()`:
```
mysqli_connect(<адрес сервера>, <имя пользователя>, <пароль>, <имя базы данных>);
```

### Проверка соединения
*Первое, что нужно сделать после соединения с СУБД - это выполнить проверку, что оно было успешным.*  
Эта проверка нужна, чтобы исключить ошибку при подключении к БД.
Неверные параметры подключения, неправильная настройка или высокая нагрузка заставит MySQL отвеграть новые подключения. Все эти ситуации приведут к невозможности соединения, поэтому 
программист должен проверить успешность подключения к серверу, прежде чем выполнять следующие действия.  

Соединение с MySQL устанавливается один раз в сценарии, а затем используется при всех запросах к БД.  
Результатом выполнения функции `mysqli_connect()` будет значение специального типа - ресурс.   
Если подключение к MySQL не удалось, то функция `mysqli_connect()` вместо ресурса вернет логическое значение типа "ложь"  - `false`.  
Хорошей практикой будет всегда проверять значение результа выполнения этой функции и сравнивать его с ложью.  

Соединение с MySQL и проверка на ошибки:
```
<?php
$link = mysqli_connect("localhost", "root", "");
 
if ($link == false){
    print("Ошибка: Невозможно подключиться к MySQL " . mysqli_connect_error());
}
else {
    print("Соединение установлено успешно");
}
```

Функция `mysqli_connect_error()` просто возвращает текстовое описание последней ошибки MySQL.

### Установка кодировки
Первым делом после установки соединения крайне желательно явно задать кодировку, которая будет использоваться при обмене данными с MySQL. Если этого не сделать, то вместо записей со значениями, написанными кириллицой, можно получить последовательность из знаков вопроса: '?????????????????'.  
Вызови эту функцию сразу после успешной установки соединения: `mysqli_set_charset($con, "utf8");`

## Выполнение запросов
Установив соединение и определив кодировку мы готовы выполнить свои первые SQL-запросы. Ты уже умеешь составлять корректные SQL команды и выполнять их через консольный или визуальный интерфейс MySQL-клиента.  
Те же самые запросы можно отправлять без изменений и из php-сценария. Помогут в этом несколько встроенных функций языка.

### Два вида запросов
Следует разделять все SQL-запросы на две группы: 
1. Чтение информации (SELECT)
2. Модификация (UPDATE, INSERT, DELETE)

При выполнении запросов из среды PHP, запросы из второй группы возвращают только результат их исполнения: успех или ошибка.  
Запросы первой группы при успешном выполнении возвращают специальный ресурс результата. Его, в свою очередь, можно преобразовать в ассоциативный массив (если нужна одна запись) или в двумерный массив (если требуется список записей).

## Добавление записи
Вернемся к нашему проекту - дневнику наблюдений за погодой.  Начнем практическую работу с заполнения таблиц данными.  Для начала добавим хотя бы один город в таблицу cities.  

Выражение `INSERT INTO` используется для добавления новых записей в таблицу базы данных.  

Составим корректный SQL запрос на вставку записи с именем города, а затем выполним его путем передачи этого запроса в функцию `mysqli_query()`, чтобы добавить новые данные в таблицу. 

```
<?php
$link = mysqli_connect("localhost", "root", "");

$sql = 'INSERT INTO cities SET name = "Санкт-Петербург"';
$result = mysqli_query($link, $sql);  

if ($result == false) {
    print("Произошла ошибка при выполнении запроса");
}
```

Обрати внимание, что первым параметром для функциии `mysqli_query()` передается ресурс подключения, полученный от  функции `mysqli_connect()`, вторым параметром следует строка с SQL запросом.  
При запросах на изменение данных (не SELECT) результатом выполнения будет логическое значение - true или false.    
`false` будет означать, что запрос выполнить не удалось. 
Для получения строки с описанием ошибки существует функция `mysqli_error($link)`.

### Как получить идентификатор добавленной записи
Следующим шагом будет добавление погодной записи для нового города.  
Погодные записи хранит таблица weather_log, но чтобы сослаться на город необходимо знать идентификатор записи из таблицы cities.  
Здесь пригодится функция `mysqli_insert_id()`.  
Она принимает единственный аргумент - ресурс соединения, а возвращает идентификатор последней добавленной записи.
 
Теперь у нас есть все необходимое, чтобы добавить погодную запись.  
Вот как будет выглядеть комплексный пример с подключением к MySQL и добавлением двух новых записей:

```
<?php
$link = mysqli_connect("localhost", "root", "");

if ($link == false){
    print("Ошибка: Невозможно подключиться к MySQL " . mysqli_connect_error());
}
else {
    $sql = 'INSERT INTO cities SET name = "Санкт-Петербург"';
    $result = mysqli_query($link, $sql);  
    
    if ($result == false) {
        print("Произошла ошибка при выполнении запроса");
    }
    else {
        $city_id = mysqli_insert_id($link);
        
        $sql = 'INSERT INTO weather_log SET city_id = ' . $city_id . ', day = "2017-09-03", temperature = 10, cloud = 1';
        
        $result = mysqli_query($link, $sql);  
        
        if ($result == false) {
            print("Произошла ошибка при выполнении запроса");
        }
    }
}
```

## Чтение записей
Другая частая операция при работе с базами данных в PHP - это получение записей из таблиц (запросы типа SELECT).  
Составим SQL запрос, который будет использовать `SELECT` выражение. Затем выполним этот запрос с помощью функции `mysqli_query()`, чтобы получить данные из таблицы.

В этом примере показано как выполнить показ всех существующих городов из таблицы cities:
```
<?php

$sql = 'SELECT id, name FROM cities';

$result = mysqli_query($link, $sql);

while ($row = mysqli_fetch_array($result)) {
    print("Город: " . $row['name'] . "; Идентификатор: . " . $row['id'] . "<br>");
}
```

В примере выше, результат выполнения функции `mysqli_query()` сохранен в переменной `$result`.  
Важно понимать, что в этой переменной находятся не данные из таблицы, а специальный тип данных - так называемая ссылка на результаты запроса.  

Чтобы получить действительные данные, т.е. записи из таблицы, следует использовать другую функцию - `mysqli_fetch_array()` и передать ей единственным параметром эту самую ссылку.  
Теперь каждый вызов функции `mysqli_fetch_array()` будет возвращать следующую запись из всего результатируещего набора записей в виде ассоциативного массива.
  
Цикл `while` здесь используется для "прохода" по всем записям из полученного набора записей.  
Значение поля каждой записи можно узнать просто обратившись по ключу этого ассоциативного массива.

### Как получить сразу все записи в виде двумерного массива
Иногда бывает удобно после запроса на чтение не вызывать в цикле `mysqli_fetch_array` для извлечения очередной записи по порядку, а получить их сразу все одним вызовом. PHP так тоже умеет. 
Функция `mysqli_fetch_all($res, MYSQLI_ASSOC)` вернет двумерный массив со всеми записями из результата последнего запроса.  
Перепишем пример с показом существующих городов с её использованием:

```
<?php

$sql = 'SELECT id, name FROM cities';
$result = mysqli_query($link, $sql);

$rows = mysqli_fetch_all($result, MYSQLI_ASSOC)

foreach ($rows as $row) {
    print("Город: " . $row['name'] . "; Идентификатор: . " . $row['id'] . "<br>");
}
```

### Как узнать количество записей
Часто бывает необходимо узнать сколько всего записей вернет выполненный SQL запрос.  
Это может быть нужно для организации постраничной навигации или просто в качестве информации.  
Узнать число записей поможет функция `mysqli_num_rows()`, которой следует передать ссылку на результат запроса.

## Безопасность

### Внедрение SQL-кода

Внедрение SQL-кода (SQL инъекция) - один из распространённых способов взлома сайтов, работающих с базами данных. 
Способ основан на внедрении в запрос произвольного SQL-кода.  
Внедрение SQL позволяет хакеру выполнить произвольный запрос к базе данных (прочитать содержимое любых таблиц, удалить, изменить или добавить данные).  

Атака этого типа возможна когда недостаточно фильтруются входные данные при использовании в SQL запросах.  

**Принцип атаки внедрения SQL**  

Допустим, на нашем сайте есть страница показа истории погодных наблюдений для одного города. Идентификатор этого города передается в ссылке в параметре запроса: `/weather.php?city_id=<ID>`, где `ID` - это первичный ключ города.  
В PHP-сценарии используем этот параметр для подстановки в SQL запрос:  
```
$city_id = $_GET['city_id'];
$res = mysqli_query($link, "SELECT * FROM weather_log WHERE city_id = " . $city_id);
```

Если на сервере передан параметр city_id, равный 10 (`/weather.php?city_id=10`), то выполнится SQL запрос:  
`SELECT * FROM weather_log WHERE city_id = 10`  

Но если злоумышленник передаст в качестве параметра id строку `-1 OR 1=1`, то выполнится запрос:  
`SELECT * FROM weather_log WHERE city_id = -1 OR 1=1`

Добавление во входные параметры конструкций языка SQL (вместо простых значений) изменяет логику выполнения всего SQL запроса!  
В этом примере вместо показа данных по одному городу будут получены данные по всем городам, потому что выражение 1=1 всегда истинно. Вместо выражения `SELECT ...` могло быть выражение на обновление данных и тогда последствия были бы еще серьезнее.  

Отсутствие должной обработки параметров SQL запроса - это одна из самых серьезных уязвимостей в вашем коде. Никогда не вставляйте данные от пользователя в SQL запросы "как есть"!

### Приведение к целочисленному типу

В SQL запросы часто подставляются целочисленные значения от пользователя. В примерах выше использовался идентификатор города, полученный из параметров запроса. Этот идентификатор можно принудительно привести к числу. Так мы исключим появление в нем опасных выражений. Если хакер передаст в этом параметре вместо числа SQL код, то результатом приведения будет ноль и логика всего SQL запроса не изменится.  

PHP умеет присваивать переменной новый тип. 
Этот код принудительно назначит переменной целочисленный тип:  
```
$city_id = $_GET['city_id'];
settype($city_id, 'integer');
```  

После преобразования переменную `$city_id` можно без опаски использовать в SQL запросах.

### Экранирование значений

Что делать, если в SQL запрос требуется подставить строковое значение? Например, на сайте есть возможность поиска города по его названию. Форма поиска передаст поисковый запрос в GET-параметр, а мы используем его в SQL запросе:  
```
$city_name = $_GET['search'];
$sql = "SELECT * FROM cities WHERE name LIKE('%$city_name%')";
```

Но если в параметре `city_name` будет символ кавычки, то смысл запроса можно кардинально изменить. Передав в search_text значение `')+and+(id<>'0`, мы выполним запрос:  
`SELECT * FROM cities WHERE name LIKE('%') AND (id<>'0%'))`  
что выведет список всех городов.  
Смысл запроса поменялся, потому что кавычка из параметра запроса считается управляющим символом: MySQL определяет окончание значение по символу кавычки после него, поэтому сами значения кавычки содержать не должны.  
Очевидно, приведение к числовому типу не подходит для строковых значений. Поэтому, чтобы обезопасить строковое значение,используют операцию **экранирования**.  

Экранирование это добавление в строке перед кавычками (и другими спецсимволами) знака апострофа `\`.  
Такая обработка лишает кавычки их статуса - они больше не определяют конец значения, а значит не могут повлиять на логику SQL выражения.  
  
За экранирование значений отвечает функция `mysqli_real_escape_string()`.  
Этот код обработает значение из параметра, сделав его безопасным для использования в запросе:  
```
$city_name = mysqli_real_escape_string($link, $_GET['search']);
$sql = "SELECT * FROM cities WHERE name LIKE('%$city_name%')";
```

### Подготовленные выражения

Вид атака типа "SQL-инъекция" возможен, потому что значения (данные) для SQL запроса передаются вместе с самим запросом. 
Т.к. данные не отделены от SQL кода, они могут влиять на логику всего выражения. К счастью, MySQL предлагает способ передачи данных отдельно от кода. Такой способ назаывается **подготовленными выражениями**.  

Выполнение подготовленных запросов состоит из двух этапов: вначале формируется шаблон запроса - обычное SQL выражение, но без действительных значений, а затем, отдельно, в MySQL передаются значения для этого шаблона.  
Первый этап называется подготовкой, а второй - выражением. Подготовленный запрос можно выполнять несколько раз, передавая туда разные значения.

**Этап подготовки**  
На этапе подготовки формируется SQL запрос, где на месте значений будут находиться знаки вопроса - плейсхолдеры. Эти плейсхолдеры в дальнейшем будут замены на реальные значения. Шаблон запроса отправляется в MySQL сервер для его анализа и синтаксической проверки.  
Пример:  
```
$sql = "SELECT * FROM cities WHERE name = ?";
$stmt = mysqli_prepare($link, $sql);
```
Этот код сформирует подготовленное выражение для выполнения вашего запроса.  

За подготовкой идет выполнение. Во время запуска запроса PHP привязывает к плейсхолдерам реальные значения и посылает их на сервер. За передачу значений в подготовленный запрос отвечает функция `mysqli_stmt_bind_param()`. Она принимает тип и сами переменные:  

```
mysqli_stmt_bind_param($stmt, 's', $_GET['search']);
```

После выполнения запроса получить его результат в формате mysqli_result можно функцией `mysqli_stmt_get_result()`:  
```
$res = mysqli_stmt_get_result($stmt);

// чтение данных
while ($row = mysqli_fetch_assoc($res)) {
    // ассоциативный массив с очередной записью из результата 
    var_dump($row);
}
```

Значения привязанных к запросу переменных сервер экранирует автоматически. Привязанные переменные отправляются на сервер отдельно от запроса и таким образом не могут влиять на него. Сервер использует эти значения непосредственно в момент выполнения, уже после того, как был обработан шаблон выражения. Привязанные параметры не нуждаются в экранировании, так
как они никогда не подставляются непосредственно в строку запроса. 