---
layout: page
title: "Знакомство с языком. Часть 2"
permalink: part2.html
---

## Продолжаем изучать синтаксис языка

### Массивы

Массив - это еще один тип данных, вроде числа или строки. Главное отличие массива от остальных типов данных - это его способность хранить в переменной больше одного значения.
В предыдущих примерах имя переменной всегда ассоциировалось только с одним значением:
* `$name = "Иннокентий"`
* `$age = 42`

Но что если мы хотим узнать у пользователя не только его пол, имя и возраст, но и, допустим, любимые сериалы. 
Очень непросто назвать один самый любимый сериал, а вот вспомнить несколько - намного легче.
Так выглядит сохранение в переменную-массив нескольких значений:
`$fav_shows = ["game of thrones", "american horror storry", "walking dead"]`  

В этом примере мы сохранили в переменной `$fav_shows` сразу три значения. Но сохранить эти данные - это только половина дела. Как с ними потом работать?
Уже знакомый способ вывода переменной на экран с массивами, к сожалению, работать не будет:
```
<?php
print("Мои любимые сериалы: " . $fav_shows);
```
Так увидеть список любимых сериалов не получится.
Дело в том, что массив - это не совсем обычная переменная.
Массив хранит не простые типы, вроде текста или чисел (их еще называют "скалярными типами"), а более сложную структуру данных, поэтому здесь нужен особый подход.  

Внутри массива у каждого значения есть свой адрес, по которому к нему можно обратиться. Такой адрес называется индексом. 
Индекс - это просто порядковый номер. Индексация начинается с нуля, так что первый элемент получает индекс - "0", второй - "1" и так далее.  

Итак, чтобы получить определенный элемент массива, необходимо знать его индекс (ключ).
Покажем названия всех сериалов из массива, разделив их запятыми:
```
<?php
print("Мои любимые сериалы: " . $fav_shows[0] . ", " . $fav_shows[1] . ", " . $fav_shows[2]);
```
Теперь можно дать определение массива:  
*Массив - это совокупность множества элементов вида "ключ : значение".*

Массивы позволяют перезаписывать существующие значения, а также добавлять новые.
Чтобы добавить в массив новое значение, существует такая инструкция:
`$fav_shows[] = "the big bang theory"`  
Новый элемент массива автоматически получит индекс равный максимальному индексу из существующих + 1. 
В нашем случае "теория большого взрыва" сохранится под индексом 4.

Теперь посмотрим как заменить любой элемент массива.
Вдруг нам перестал нравиться один из сериалов, т.к. новый сезон оказался очень плох или появился новый фаворит.
Чтобы вычеркнуть старое значение и заменить его новым, надо просто присвоить новое значение любому из существующих в массиве индексов:
`$fav_shows[4] = "fargo"`

Для полного удаления (без замены на другое) значения по его индексу существует функция `unset`: `unset($fav_shows[4])`

#### Ассоциативные массивы
В предыдущем разделе мы познакомились с так называемыми простыми массивами. Но в PHP существует еще и другой, чуть более сложный тип массивов — ассоциативные. 
Ассоциативные массивы отличаются от простых только тем, что вместо индексов у них ключи. 
И если индекс всегда является целым, порядковым числом, то ключ может быть любой произвольной строкой. Вот для чего это нужно:
Мы уже знаем достаточно много о нашем пользователе: его имя, возраст, любимый цвет и сериалы. Есть только одно неудобство: все эти данные сейчас раскиданы по разным переменным. Как было бы удобно сохранить все эти данные внутри одного массива. Именно в таких ситуациях могут очень пригодиться ассоциативные массивы.

Запись всей информации о пользователе с помощью ассоциативного массива:
```
<?php
$user = ['age' => 42, 'name' => 'Иннокентий', 'fav_shows' => ["game of thrones", "american horror storry", "walking dead"] ];
```

Обрати внимание: массив может содержать другой массив в качестве одного из значений. 
В нашем примере мы поместили простой массив внутри ассоциативного под ключом "fav_shows".

Вывод информации из ассоциативных массивов аналогичен простым массивам.  
Показ всей информации о пользователе, сохраненном в переменной `$user`:
```
<?php
print("Имя: " . $user['name'] . " Возраст: " . $user['age'] . "
Любимые сериалы: "  . $user['fav_shows'][0] . ", " . $user['fav_shows'][1] . ", " . $user['fav_shows'][2];
```

### Циклы
Цикл - это конструкция языка, которая позволяет выполнить блок кода больше одного раза.

Мы привыкли, что наши сценарии выполняются линейно: сверху вниз, строчка за строчкой, инструкция за интструкцией. Но что делать, если надо повторить какую нибудь инструкцию несколько раз?  
Например, как вывести на экран все натуральные числа (1...9)?
Никто не мешает сделать это очевидным способом:
```
<?php
print (1);
print (2);
print (3);
// и так далее...
```

Но, во первых, такой способ заставляет писать много кода. Во-вторых: что если требуется вывести последовательность из миллиона чисел? И, наконец, бывают ситуации, когда заранее  неизвестно сколько раз нужно выполнить определенную инструкцию...  

Использование циклов значительно упрощает и укорачивает код. Также циклы незаменимы в ситуациях, когда заранее неизвестно сколько раз должен выполниться блок кода.  Такое число может зависеть от множества условий и вычисляется в момент выполнения сценария.

Так в PHP выглядит цикл:
```
<?php
while (<условие цикла>) {
<тело цикла>
}
```
В прошлой главе учебника вы познакомились с понятием выражения и его истинностью. Выражения часто используются в циклах следующим образом:
выражение помещается на место <условие цикла> и определяет, будет ли исполнен блок кода - <тело цикла>. 

Если выражение из условия цикла возвращает истину, то выполнение сразу перейдет к блоку "тело цикла", если же оно вернет ложь - то тело цикла исполнено не будет и сценарий продолжит выполняться как обычно, со следующей строки после цикла.  

Выходит, что циклы имеют такое название, потому что как бы "зацикливают" обычное, линейное исполнение на своем блоке кода и не дают сценарию выполняться дальше, пока условие цикла будет истинным.  

Важно понимать последовательность, в которой исполняется код при использовании циклов.
1. Обычное исполнение кода, строчка за строчкой, пока не встретился цикл
2. Встретился цикл: выполняем условие цикла
3. Если условие вернуло ложь: выходим из цикла, выполняем строчку после него и продолжаем линейное исполнение
3. Если условие вернуло истину: выполняем всё тело цикла
4. Повторяем пункт 2

Каждая последовательность из шагов 2-4, т.е. очередное выполнение блока кода в теле цикла - называется _итерацией_.  

Количество итераций должно быть конечным, т.е., как правило, бесконечное выполнение одного блока кода не входит в наши планы.  
А значит необходимо заранее предусмотреть ситуацию, когда истинное условие станет ложным.  

Теперь вернемся к задаче по выводу на экран всех натуральных чисел:
```
<?php
$last_num = 1;

while ($last_num < 10) {
    print($last_num);
    $last_num = $last_num + 1;
}
```
Данный цикл в своем теле содержит две инструкции. Первая выводит на экран цифру из переменной. Вторая инструкция увеличивает значение переменной на единицу.
Теперь вопрос: сколько раз будет исполнен такой цикл?

Циклы выполняются, пока их условие остается истинным, а в нашем условии значение переменной должно быть меньше десяти. Т.к. начальное значение переменной - единица, то не сложно посчитать, что цикл выполнится ровно девять раз. На десятый раз значение переменной `$last_num` станет равно десяти и условие `$last_num < 10` перестанет быть истинным.

#### Циклы и массивы

Чаще всего циклы используются для работы с массивами. А конкретнее - для перечисления всех элементов массива и выполнения какого нибудь действия с каждым из этих элементов.  
Умение использовать циклы и массивы совместно, сразу позволит тебе выполнять множество интересных и разнообразных задач!

Чуть раньше мы уже научились работать с массивами. Например, мы можем показать все значения массива, обратившись к каждому из элементов по его индексу. Но это чрезвычайно утомительно: обращаться к каждому из элементов массива по очереди, когда мы просто хотим показать всего его значения. Циклы избавят от этой рутины!

С помощью циклов можно показать содержимое любого массива и это потребует всего несколько строк кода!  

Перепишем пример с выводом списка любимых сериалов, но теперь задействовав цикл:
```
<?php
$fav_shows = ["game of thrones", "american horror storry", "walking dead"];
$cur_index = 0;

while ($cur_index < 3) {
    print($fav_shows[$cur_index] . ", ");
    $cur_index = $cur_index + 1;
}
```
В этом примере цикл выводит элемент по индексу. Индекс теперь находится в переменной `$cur_index` и начальное значение у него ноль. Значение переменной увеличивается на единицу с каждой итерацией цикла, пока не достигнет трех. В этот момент условие `$cur_index < 3` перестанет быть истинным и цикл остановится, перебрав весь массив.

#### foreach - специальный цикл для массивов
Настало время узнать, что циклы в PHP могут быть разных типов. Выше мы познакомились с циклом типа `while`. Главная особенность этого типа  в том, что необходимо указывать выражение в его условии. Но `while` - это не единственный вид циклов в PHP. Есть еще как минимум два других. 

Массивы и циклы так часто используются вместе, что разработчики языка даже добавили вид цикла специально для перебора массивов. Он называется `foreach`.
Но что не так с обычным `while` и зачем понадобилось придумывать этот `foreach`?

Дело в том, что цикл `while` слишком универсален. А платой за эту универсальность всегда будет более сложный и обьемный код. Приходится придумывать условие, следить, чтобы оно не было бесконечным. А в теле цикла обязательно надо не забыть увеличивать переменную-счетчик. И все это нужно для простого перебора элементов массива. Неужели нельзя сделать проще?

К счастью, `foreach` решает все эти проблемы. Вот его возможности: 
* **не требуется писать условие**
* позволяет получать ключи массива
* сам присваивает очередной элемент массива переменной

Цикл `foreach` становится совершенно незаменим, когда дело доходит до итерации по ассоциативным массивам.
Возьмем такой пример: у нас есть данные пользователя, которые хранятся в ассоциативном массиве. На сайте понадобилось сделать страницу с информацией об этом юзере. Задача состоит в том, чтобы показать на странице все данные, которые известны об этом человеке. 
Выглядеть это должно так:
| Ключ | Значение |
| ----------- | ----------- |
| **Имя** | Евгений |
| **Возраст** | 27 |
| **Род занятий** | Программист |

Оригинальный массив, который надо показать в таком виде:
```
$user = ['Имя' => 'Евгений', 'Возраст' => '27', 'Род занятий' => 'Программист'];
```

Код сценария, который обойдет массив и покажет все его содержимое займет всего 4 строчки:
```
foreach ($user as $key => $value) {
    print($key . ': ');
    print($value . '<br>');
}
```
На каждой итерации цикла, внутри его тела будут определяться переменные `$key` и `$value`. В первую будет попадать очередной ключ массива, а во вторую - очередное значение по этому ключу.

### Функции
Если говорить простым языком, то функция - это блок кода, который может быть именован и вызван повторно. Иногда функцию еще называют _подпрограммой_.
Мы привыкли, что обычной переменной можно присвоить число, строку или массив, а затем получить его обратно, обратившись к значению по имени переменной. Функция устроена очень похоже. Это тоже своего рода переменная, только вместо строки или числа, в ней хранится блок кода, который вызывается при использовании этой "переменной".

Функция - это очень мощный инструмент повторного использования кода. Ведь создав свою функцию и записав туда необходимый код, ты сможешь вызывать и использовать его столько раз, сколько необходимо. В противном случае пришлось бы копировать и вставлять фрагмент кода каждый раз, когда он понадобится.

Чтобы упростить себе работу, мы можем оформить в виде функции некоторую часть кода, которая используется несколько раз в сценарии. Затем, вместо копирования и вставки этой части кода, будет достаточно только вызывать эту функцию, как если бы мы обращались к переменной.

Разделяют два типа функций - **встроенные** и **пользовательские**.

**Встроенные** функции - это функции, которые за нас уже написали создатели языка программирования и мы можем просто брать их и использовать.
В PHP существуют тысячи готовых функций на все случаи жизни!

Одна из таких, уже очень хорошо знакомых нам функций - это функция, которая выводит переданный ей текст на экран - `print()`

**Пользовательские функции** программист создает самостоятельно. Эти функции, как правило, используются только внутри одного проекта или, даже, сценария.

#### Анатомия функций
Как и с обычными переменными, работа с функциями состоит из их объявления и использования.  
Перед тем как использовать новую функцию, следует её объявить:  
```
<?php
function <имя функции>(<аргумент функции>) {
    <тело функции>
    return <результат выполнения функции>;
}
```
Пояснить все составные части функции проще всего на примере.  
На своем сайте мы хотим показывать, является ли переданный пользователем год високосным. Для этого напишем функцию, в которую передается год. В результате работы функции мы хотим получить значение "истина", если год високосный, и "ложь" - если нет.  
Определение такой функции:
```
<?php
function is_leap_year($year) {
    if ($year % 4 != 0) {
        return false;
    elseif ($year % 100 == 0) {
        if ($year % 400 == 0) {
            return true;
        }
        else {
            return false;
        }
    }
    else {
        return true;
    }
}
```

Пример использования функции:
```
<?php
$year = 2034;

if (is_leap_year($year)) {
    print("2034 год - простой");
}
else {
    print ("2034 год - високосный");
}
```

##### Аргументы функции и область видимости
Наша функция умеет вычислять, является ли переданный год високосным.  
Важно понимать, что функция - это как бы программа в программе, вещь в себе. Это значит, что внутри такой функции не будут доступны переменные, которые определялись за её пределами. Чтобы передать внутрь функции информацию извне нужно использовать аргументы функции.  

*Аргументы функции* - это переменные, которые функция может получить. При определении функции мы именуем переменные, которые функция может получить из внешнего кода. В примере с `is_leap_year` такая переменная была только одна - `$year`.  

Аргументы необходимы, т.к. функция "не видит" переменные, определенные за её границами. Поэтому нужные переменные надо передавать ей явно.  
Верно и обратное - переменные, определенные внутри функции, не будут доступны извне. Такие переменные называются локальными, потому что они локальны по отношению к функции.  

В отличие от аргументов, которых может быть несколько, вернуть во внешний код функция может только одно значение - с помощью инструкции "return" (возврат). 
Возвращаемое значение называют результатом работы функции.
